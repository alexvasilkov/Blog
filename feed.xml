<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-05-12T17:30:42+00:00</updated><id>/</id><title type="html">Alex Vasilkov</title><subtitle>Software blog</subtitle><entry><title type="html">Git repos as Gradle dependencies</title><link href="/gradle-git" rel="alternate" type="text/html" title="Git repos as Gradle dependencies" /><published>2020-05-12T07:00:00+00:00</published><updated>2020-05-12T07:00:00+00:00</updated><id>/gradle-git</id><content type="html" xml:base="/gradle-git">&lt;p&gt;It is not an uncommon desire to split your codebase into reusable libraries (git repositories).
Let’s review what options we have if we want to include external code into a Gradle project.&lt;/p&gt;

&lt;h2 id=&quot;git-submodules&quot;&gt;Git submodules&lt;/h2&gt;

&lt;p&gt;An obvious choice can be git submodules. Creating a git submodule is easy:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git submodule add &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;url&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;name&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And then you need to manually download submodules with&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;git submodule update &lt;span class=&quot;nt&quot;&gt;--init&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--recursive&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Looks simple, but using git submodules can quickly become painful.
GitHub &lt;a href=&quot;https://github.blog/2016-02-01-working-with-submodules/&quot;&gt;does not recommend&lt;/a&gt; to use it in most cases, because:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Git doesn’t download submodule contents by default.&lt;/li&gt;
  &lt;li&gt;Difficult to contribute changes back to the submodule repository.&lt;/li&gt;
  &lt;li&gt;Collaborators won’t automatically see updates to submodules.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you have a simple use case and want to include an external repository that will change rarely
then this option can be good enough.&lt;/p&gt;

&lt;h2 id=&quot;binary-artifacts&quot;&gt;Binary artifacts&lt;/h2&gt;

&lt;p&gt;The most popular option is to publish shared code as binary (&lt;code class=&quot;highlighter-rouge&quot;&gt;.jar&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;.aar&lt;/code&gt;) artifacts
in an external Maven repository.&lt;/p&gt;

&lt;p&gt;Open source libs can be distributed with one of a few free public Maven repositories like
&lt;a href=&quot;https://www.sonatype.com/nexus-repository-oss&quot;&gt;Sonatype&lt;/a&gt;, &lt;a href=&quot;https://bintray.com/bintray/jcenter&quot;&gt;Bintray&lt;/a&gt;, etc. But if you want to distribute privately within a
company then you’ll need to maintain your own private Maven repository
(e.g. &lt;a href=&quot;https://www.jfrog.com/confluence/display/RTF6X/Installing+Artifactory&quot;&gt;Artifactory&lt;/a&gt;), pay for external services (e.g. &lt;a href=&quot;https://jfrog.com/article/private-repositories/&quot;&gt;Bintray&lt;/a&gt;),
or try to &lt;a href=&quot;https://stackoverflow.com/questions/14013644/hosting-a-maven-repository-on-github&quot;&gt;use git repo&lt;/a&gt; as a Maven repository.&lt;/p&gt;

&lt;p&gt;If you store your code on GitHub then you can use &lt;a href=&quot;https://github.com/features/packages&quot;&gt;GitHub Packages&lt;/a&gt;,
it is also available for private repositories, the main downside of this service is a storage limit.&lt;/p&gt;

&lt;p&gt;Once published it becomes very easy to use the library by adding it as a regular Gradle dependency.
But this approach has a few important limitations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Requires private Maven repository for non-public libraries.&lt;/li&gt;
  &lt;li&gt;Requires non-trivial build script configuration.&lt;/li&gt;
  &lt;li&gt;Requires extra efforts to publish new versions. Can be a problem for frequently changing projects.&lt;/li&gt;
  &lt;li&gt;Testing library code in a host project requires publishing a new snapshot version of the library,
and repeating it until all issues are resolved.&lt;/li&gt;
  &lt;li&gt;Android flavors and build modes are not supported.
Separate artifacts should be published for different lib’s variants.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall this is a great option for public libraries, for big companies, or when no frequent changes
are expected. In other cases it may become frustrating to make changes to the libraries and maintain
the necessary infrastructure.&lt;/p&gt;

&lt;h2 id=&quot;jitpack&quot;&gt;JitPack&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://jitpack.io/&quot;&gt;JitPack&lt;/a&gt; is a nice service that builds git repos on their servers on your behalf,
it supports lots of git hostings (GitHub, Bitbucket, Gitlab), supports
&lt;a href=&quot;https://jitpack.io/docs/PRIVATE/&quot;&gt;private repositories&lt;/a&gt; and even supports Android flavors. The usage is simple:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maven&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://jitpack.io'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'com.github.User:Repo:Tag'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Overall it’s an interesting combo of a regular (“manual”) Maven repository and CI server.
It is indeed much easier to set up a library and release new versions with JitPack. Though it still
has some of drawbacks of a regular binary distribution:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Requires paid monthly subscription for non-public libraries.&lt;/li&gt;
  &lt;li&gt;Testing library code in a host project requires pushing changes to remote repo and waiting
for JitPack to build it.&lt;/li&gt;
  &lt;li&gt;Less control of the distribution process. E.g. no checks and tests (unless using JitPack CI),
end users may use any commits / branches as if they were real versions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gradle-source-dependencies&quot;&gt;Gradle source dependencies&lt;/h2&gt;

&lt;p&gt;Source dependencies feature was &lt;a href=&quot;https://blog.gradle.org/introducing-source-dependencies&quot;&gt;introduced&lt;/a&gt; back in Gradle 4.x,
it works by including a regular dependency:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'org.gradle.cpp-samples:utilities:1.0'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;and specifying how to get it from external git repo, in &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.gradle&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;sourceControl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gitRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'https://github.com/gradle/native-samples-cpp-library.git'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;producesModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'org.gradle.cpp-samples:utilities'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Gradle will download the sources from the (public) git repository and will try to build a binary
artifact out of it. But this option has rather strict limitations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Only public repositories are supported at the moment (see &lt;a href=&quot;https://github.com/gradle/gradle/issues/8245&quot;&gt;this bug report&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;The project in git repo should be properly configured so that Gradle knows how to build and identify its artifact.&lt;/li&gt;
  &lt;li&gt;Plus most of the same issues from the binary distribution option, as stated above.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall this option does not look promising, it has lots of limitations and a fairly complicated setup.&lt;/p&gt;

&lt;h2 id=&quot;gradle-plugin&quot;&gt;Gradle plugin&lt;/h2&gt;

&lt;p&gt;Another alternative is to use a &lt;a href=&quot;https://github.com/alexvasilkov/GradleGitDependenciesPlugin&quot;&gt;Gradle plugin&lt;/a&gt; (written by the author of this
article). It helps to fetch and attach external git repositories as dependencies.
For the last 5 years we successfully used the first
version of this plugin in our company, and now I’m glad to introduce the second version,
with a cleaner DSL and some minor fixes. Let’s check the usage.&lt;/p&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.gradle&lt;/code&gt; file, declare the plugin:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;plugins&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'com.alexvasilkov.git-dependencies'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2.0.1'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p class=&quot;code_comment&quot;&gt;
Note that for Gradle prio 6.x a more verbose declaration is needed, see plugin docs.
&lt;/p&gt;

&lt;p&gt;In module’s &lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt; file, declare a git repository as dependency:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://example.com/repository.git'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'v1.2.3'&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now the plugin will take care of downloading (or updating) specified git repo into &lt;code class=&quot;highlighter-rouge&quot;&gt;libs/{git name}&lt;/code&gt;
directory and attaching it as a &lt;a href=&quot;https://docs.gradle.org/current/userguide/declaring_dependencies.html#sub:project_dependencies&quot;&gt;project dependency&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Key features:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Both https and ssh authorization are supported.&lt;/li&gt;
  &lt;li&gt;Dependencies are resolved recursively, i.e. your git repository can define other git repositories
as dependencies.&lt;/li&gt;
  &lt;li&gt;Versions conflict detection. If the same repository is declared with different commit, tag or
branch then the build will fail.&lt;/li&gt;
  &lt;li&gt;Attached repositories can be safely edited and tested directly in the host project.&lt;/li&gt;
  &lt;li&gt;Seamless Android flavors support, since git repos are treated as regular modules.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The plugin will resolve and download git repos before Gradle projects (modules) are evaluated,
so one of the cool features is that you can move all your build scripts into a separate repo as well
and then reuse them by declaring in &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.gradle&lt;/code&gt; like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fetch&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://example.com/build_scripts_repo.git'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;$rootDir/gradle/scripts&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'v1.2.3'&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now your shared build scripts are available in all the projects with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;from:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;$rootDir/gradle/scripts/{your_script}.gradle&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In general this option is similar to git submodules but without most of its issues.
There are still some issues worth mentioning:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Requires downloading and compiling source code, in contrast to pre-compiled binary artifacts.&lt;/li&gt;
  &lt;li&gt;No Kotlin DSL support yet.&lt;/li&gt;
  &lt;li&gt;No official support / maintenance from big companies to rely on.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It is always a good idea to separate and reuse repeatedly used code into a dedicated library
project. For public libraries binary artifacts distribution is the most popular
and recommended option, while private libraries distribution can be trickier. If you wish to avoid
building and distributing binary artifacts within your company then the Gradle plugin presented in
this article can be a good alternative. As a side effect it also provides a mechanism to reuse your
build scripts logic among several projects.&lt;/p&gt;</content><author><name>Alex Vasilkov</name></author><category term="Gradle" /><summary type="html">It is not an uncommon desire to split your codebase into reusable libraries (git repositories). Let’s review what options we have if we want to include external code into a Gradle project.</summary></entry></feed>